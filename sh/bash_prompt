#!/bin/bash
#
# bash_prompt
# bash-specific prompting

# Helper definitions
COLOUR_RED="\[\e[31m\]"
COLOUR_NONE="\[\e[0m\]"
case $(uname) in
    Darwin)
        PS_ARROW="»"
        # PS_DIRTY="✗"
        PS_DIRTY="*"
        # PS_FAIL="‼"
        ;;
    *)
        PS_ARROW=">"
        PS_DIRTY="*"
        # PS_FAIL="!"
        ;;
esac

# Helper functions
__parse_git_dirty () {
    local marker=$PS_DIRTY
    if [[ -n "$1" ]]; then
        marker="$1"
    fi
    git status 2> /dev/null | grep -c : | awk "{if (\$1 > 0) print \"$marker\"}"
}
__parse_svn_dirty () {
    if [[ -d '.svn' ]]; then
        local marker="$PS_DIRTY"
        if [[ -n "$1" ]]; then
            marker="$1"
        fi
        if svn status|egrep -q . ; then
            builtin echo -ne " (svn)$marker"
        fi
    fi
}
__pwd_with_tilde () {
    echo $PWD | sed -e "s:$HOME:~:"
}


# Set the prompt depending on the last exit status
__prompt_func () {
    local retval=$?
    local prompt='\w$(__git_ps1)$(__parse_git_dirty)$(__parse_svn_dirty) $PS_ARROW '
    if [[ $retval -eq 0 ]]; then
        PS1="$prompt"
    else
        PS1="$COLOUR_RED$PS_FAIL[$retval]$COLOUR_NONE $prompt"
    fi
}

# Set terminal titles 
__term_func () {
    print_term_title "$(__pwd_with_tilde)$(__git_ps1)$(__parse_git_dirty "*")$(__parse_svn_dirty)"
}

# Bring it all together
PROMPT_COMMAND='__prompt_func ; __term_func'
