<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>ClassName</key>
		<string>XCUserScriptGroup</string>
		<key>name</key>
		<string>Open</string>
		<key>subNodes</key>
		<array>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.sh</string>
				<key>name</key>
				<string>Open Path in Text Edit</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Opens the selected file path in TextEdit

xargs open -e 
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>0</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>04103ED5-1758-4881-BEDD-268AB9C31553</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.sh</string>
				<key>name</key>
				<string>Open Path or URL</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Opens the selected file path or URL

xargs open
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>0</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>C8588D1C-9151-47CE-BE3C-0A54EAFDEC7E</string>
			</dict>
		</array>
		<key>uuid</key>
		<string>D8A081D7-4D08-4204-9047-04EBCC2F7C7A</string>
	</dict>
	<dict>
		<key>ClassName</key>
		<string>XCUserScriptGroup</string>
		<key>name</key>
		<string>Search</string>
		<key>subNodes</key>
		<array>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.sh</string>
				<key>name</key>
				<string>Search Google for Selection</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Searches www.google.com for the selected text

INPUT=`cat -`

open "http://www.google.com/search?ie=UTF-8&amp;q=${INPUT}&amp;btnG=Google+Search"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>0</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>9A158C5D-8476-40DF-B0F3-C2E32106F5C1</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.sh</string>
				<key>name</key>
				<string>Search Apple Developer Site for Selection</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Searches developer.apple.com for the selected text

INPUT=`cat -`

open "http://developer.apple.com/cgi-bin/search.pl?q=${INPUT}&amp;ie=utf8&amp;oe=utf8"
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>0</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>AD8073E2-FF86-48C3-AA3D-778C13DF1741</string>
			</dict>
		</array>
		<key>uuid</key>
		<string>7AAE141E-344D-4CC2-B0D8-AD623D22FE4E</string>
	</dict>
	<dict>
		<key>ClassName</key>
		<string>XCUserScriptGroup</string>
		<key>name</key>
		<string>Comments</string>
		<key>subNodes</key>
		<array>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string>@/</string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Un/Comment Selection</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
#
# un_commentLines.pl - 	Comments or uncomments the selected lines
#			Uses '# ' for Perl and shell scripts; '// ' otherwise

my $outputString = "";
my $perlCmt = "#";
my $cCmt = "//";

# Get the first few lines of the file
my $fileString = &lt;&lt;'HEADTEXT';
%%%{PBXHeadText}%%%
HEADTEXT


# determine the type of file we have by looking for the #! line at the top
# careful--it might already be commented out!
my $commentString;
if ($fileString =~ m!^($perlCmt|$cCmt)?#\!\s*.*?/perl|^($perlCmt|$cCmt)?#\!\s*.*?/sh!) {
	$commentString = $perlCmt;
} else {
	$commentString = $cCmt;
}

my @selection = &lt;STDIN&gt;;       # read the selection from standard input

# no chars in selection, so create an empty selection
if (!@selection) {
    push @selection, "";
};  

# add or remove comment markers depending on the state of the first line of the selection
# if it is uncommented, comment all lines.  If it is commented, remove comment markers, if present
my $firstLineOfSelection = $selection[0]; #get first line
my $addingCommentsString = 1;
if ($firstLineOfSelection =~ /^$commentString/) { #selection starts with comment
    $addingCommentsString = 0;
}

foreach my $line (@selection) {
    if ($addingCommentsString == 1) {
        $outputString .= $commentString.$line;
    } else {
        $line =~ s/^$commentString//;
        $outputString .= $line;
    }
}

print "%%%{PBXSelection}%%%";
print $outputString;
print "%%%{PBXSelection}%%%";
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>CCC886A0-0579-48F5-B6D9-D97A23128C5C</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Un/Backslash Selection</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
#
# backslashLines.pl - 	adds or deletes a backslash at the ends of the selected lines

my $outputString = "";

my @selection = &lt;STDIN&gt;;       # read the selection from standard input

if (!@selection) { exit; };  # no chars in selection, nothing to do

# add or remove backslash depending on the state of the first line of the selection
my $firstLineOfSelection = $selection[0]; # get first line
my $addingBackslash = 1;
if ($firstLineOfSelection =~ /\\$/) { #selection ends with backslash
    $addingBackslash = 0;
}

# get the length of the longest line
my $longest=0;
foreach my $line (@selection) {
    my $lineLength = length($line);
    if ($lineLength &gt;$longest) {
        $longest = $lineLength;
    }
}

# add an offset to the longest line, for location of continuation character
my $paddedLength = $longest + 5;

my $numLines = scalar(@selection);
my $lastLineIndex= $numLines - 1;

for (my $i = 0; $i &lt; $numLines ; $i++) {
    my $line = $selection[$i];
    if ($addingBackslash == 1) {
        if ($i &lt; $lastLineIndex) { 
            chomp $line;
            my $paddedLine = sprintf("%-*s", $paddedLength, $line);
            $outputString .= $paddedLine."\\\n";
        } else { # don't add continuation character on last line
            $outputString .= $line;
        }
    } else {
        $line =~ s/\s*\\$//;
        $outputString .= $line;
    }
}

print "%%%{PBXSelection}%%%";
print $outputString;
print "%%%{PBXSelection}%%%";
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>FE9A0F57-671A-4E52-984B-C48CB62C7727</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScriptSeparator</string>
				<key>uuid</key>
				<string>E01AF5A9-71E3-49A6-80C0-CC7DB93BF236</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Insert !!!:Name:Date</string>
				<key>script</key>
				<string>#!/bin/sh

echo -n "// !!!:${USER}:"
date +%Y%m%d | awk '{printf "%s", $1}'
echo -n " %%%{PBXSelection}%%%"
cat -
echo -n "%%%{PBXSelection}%%%"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>439221AC-F855-4202-97FD-AE3E687B81E7</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Insert ???:Name:Date</string>
				<key>script</key>
				<string>#!/bin/sh

echo -n "// ???:${USER}:"
date +%Y%m%d | awk '{printf "%s", $1}'
echo -n " %%%{PBXSelection}%%%"
cat -
echo -n "%%%{PBXSelection}%%%"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>D6E38EC1-FD95-444F-8DB5-C1A058E26097</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Insert :Name:Date</string>
				<key>script</key>
				<string>#!/bin/sh

echo -n "// :${USER}:"
date +%Y%m%d | awk '{printf "%s", $1}'
echo -n " %%%{PBXSelection}%%%"
cat -
echo -n "%%%{PBXSelection}%%%"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>61304851-C495-4CD1-9D96-BB965D7041F9</string>
			</dict>
		</array>
		<key>uuid</key>
		<string>544D53B7-4313-403E-BD91-8E610715FDA1</string>
	</dict>
	<dict>
		<key>ClassName</key>
		<string>XCUserScriptGroup</string>
		<key>name</key>
		<string>Code</string>
		<key>subNodes</key>
		<array>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.python</string>
				<key>name</key>
				<string>Place Accessor Decls on Clipboard</string>
				<key>script</key>
				<string>#! /usr/bin/python
# -*- coding: utf-8 -*-

# Known limitations:
#   - Multiword types (like "unsigned int") are not handled.
#   - The script attempts to determine if the type is an object or not, but it is imperfect at detecting this

import sys
import string
import re

# ================== Debug input ==================

# Set the variable below to True to run the script in test mode on the test 
# input below instead of reading input from stdin
doDebug = False

testInput = (
"""    NSString *_name;  // comment
""",
"""    IBOutlet NSButton *button;  // comment
""",
"""    NSMutableArray *_children;  /* comment */
""",
"""   /* comment */
""",
"""   // comment
""",
"""    unsigned _count;
""")

# ================== Script data ==================

# List of known scalar types (no ref-counting in accessors for these types)
knownScalarTypes = ("int", "unsigned", "char", "short", "long", "float", "double", "NSRect", "NSPoint", "NSSize", "NSRange", "BOOL")

# List of known to-many relationship types.  (Since the generated code assumes NSMutableArray, this list probably would not grow...)
knownArrayTypes = ("NSMutableArray")

# Templates for accessor methods
# Substitutions will be performed on use:
#    &lt;key&gt; -&gt; normal key name
#    &lt;capKey&gt; -&gt; capitalized key name
#    &lt;ivar&gt; -&gt; instance variable name
#    &lt;type&gt; -&gt; key's type
#

objectAccessorDecls = """\
- (&lt;type&gt;)&lt;key&gt;;
- (void)set&lt;capKey&gt;:(&lt;type&gt;)value;

"""

objectAccessorDefs = """\
- (&lt;type&gt;)&lt;key&gt; {
    return [[&lt;ivar&gt; retain] autorelease];
}

- (void)set&lt;capKey&gt;:(&lt;type&gt;)value {
    if (&lt;ivar&gt; != value) {
        [&lt;ivar&gt; release];
        &lt;ivar&gt; = [value copy];
    }
}

"""

scalarAccessorDecls = """\
- (&lt;type&gt;)&lt;key&gt;;
- (void)set&lt;capKey&gt;:(&lt;type&gt;)value;

"""

scalarAccessorDefs = """\
- (&lt;type&gt;)&lt;key&gt; {
    return &lt;ivar&gt;;
}

- (void)set&lt;capKey&gt;:(&lt;type&gt;)value {
    if (&lt;ivar&gt; != value) {
        &lt;ivar&gt; = value;
    }
}

"""

indexedAccessorDecls = """\
- (NSArray *)&lt;key&gt;;
- (unsigned)countOf&lt;capKey&gt;;
- (id)objectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex;
- (void)get&lt;capKey&gt;:(id *)objsPtr range:(NSRange)range;
- (void)insertObject:(id)obj in&lt;capKey&gt;AtIndex:(unsigned)theIndex;
- (void)removeObjectFrom&lt;capKey&gt;AtIndex:(unsigned)theIndex;
- (void)replaceObjectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex withObject:(id)obj;

"""

indexedAccessorDefs = """\
- (NSArray *)&lt;key&gt; {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    return [[&lt;ivar&gt; retain] autorelease];
}

- (unsigned)countOf&lt;capKey&gt; {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    return [&lt;ivar&gt; count];
}

- (id)objectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    return [&lt;ivar&gt; objectAtIndex:theIndex];
}

- (void)get&lt;capKey&gt;:(id *)objsPtr range:(NSRange)range {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; getObjects:objsPtr range:range];
}

- (void)insertObject:(id)obj in&lt;capKey&gt;AtIndex:(unsigned)theIndex {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; insertObject:obj atIndex:theIndex];
}

- (void)removeObjectFrom&lt;capKey&gt;AtIndex:(unsigned)theIndex {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; removeObjectAtIndex:theIndex];
}

- (void)replaceObjectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex withObject:(id)obj {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; replaceObjectAtIndex:theIndex withObject:obj];
}


"""

# ================== Runtime variables ==================

# ================== Script ==================

# Get input lines
if doDebug:
    inputLines = testInput
else:
    inputLines = sys.stdin.readlines()

# Strip comments and extra whitespace
commentRE1 = re.compile(r"[ 	]*\/\/.*$")
commentRE2 = re.compile(r"[ 	]*\/\*.*\*\/[ 	]*")

newInputLines = []
for curLine in inputLines:
    curLine = re.sub(commentRE1, "", curLine)
    curLine = re.sub(commentRE2, "", curLine)
    curLine = curLine.strip()
    if curLine != "":
        newInputLines.append(curLine)

inputLines = newInputLines

# Process each line

# Subexpressions:
#     1 - IBOutlet decl
#     2 - Type name (without pointer *'s)
#     3 - Pointer *'s from type
#     4 - Leading underbar(s) of variable name
#     5 - First letter of variable name
#     6 - Rest of variable name
declRE = re.compile(r"^(IBOutlet)?[ 	]*([_a-zA-Z][_a-zA-Z0-9]*)[ 	]*(\**)[ 	]*([_]*)([a-zA-Z])([_a-zA-Z0-9]*)[ 	]*;")

typeRE = re.compile(r"&lt;type&gt;", re.MULTILINE)
keyRE = re.compile(r"&lt;key&gt;", re.MULTILINE)
capKeyRE = re.compile(r"&lt;capKey&gt;", re.MULTILINE)
ivarRE = re.compile(r"&lt;ivar&gt;", re.MULTILINE)

resultText = ""

for curLine in inputLines:
    # Match the line and extract the subexpressions
    matchObj = re.match(declRE, curLine)
    if matchObj != None:
        # Note indices are 1 less than subexpression numbers in the comment above
        subexps = matchObj.groups()
        
        isObject = True
        isArray = False
        if subexps[1] in knownScalarTypes:
            isObject = False
        elif subexps[1] in knownArrayTypes:
            isArray = True
        
        # Figure out the substitution strings for the accessor templates
        if subexps[2] != "":
            curType = subexps[1] + " " + subexps[2]
        else:
            curType = subexps[1]
        curKey = subexps[4] + subexps[5]
        curCapKey = string.upper(subexps[4]) + subexps[5]
        curIvar = subexps[3] + subexps[4] + subexps[5]
        
        # Build the result
        if isObject:
            if isArray:
                curResultText = indexedAccessorDecls
            else:
                curResultText = objectAccessorDecls
        else:
            curResultText = scalarAccessorDecls

        curResultText = re.sub(typeRE, curType, curResultText)
        curResultText = re.sub(keyRE, curKey, curResultText)
        curResultText = re.sub(capKeyRE, curCapKey, curResultText)
        curResultText = re.sub(ivarRE, curIvar, curResultText)
        
        resultText += curResultText


# The comma suppresses adding another newline to the end
print resultText,
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>6</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>68D60653-A91C-4C27-A786-56C22403AE37</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.python</string>
				<key>name</key>
				<string>Place Accessor Defs on Clipboard</string>
				<key>script</key>
				<string>#! /usr/bin/python
# -*- coding: utf-8 -*-

# Known limitations:
#   - Multiword types (like "unsigned int") are not handled.
#   - The script attempts to determine if the type is an object or not, but it is imperfect at detecting this

import sys
import string
import re

# ================== Debug input ==================

# Set the variable below to True to run the script in test mode on the test 
# input below instead of reading input from stdin
doDebug = False

testInput = (
"""    NSString *_name;  // comment
""",
"""    IBOutlet NSButton *button;  // comment
""",
"""    NSMutableArray *_children;  /* comment */
""",
"""   /* comment */
""",
"""   // comment
""",
"""    unsigned _count;
""")

# ================== Script data ==================

# List of known scalar types (no ref-counting in accessors for these types)
knownScalarTypes = ("int", "unsigned", "char", "short", "long", "float", "double", "NSRect", "NSPoint", "NSSize", "NSRange", "BOOL")

# List of known to-many relationship types.  (Since the generated code assumes NSMutableArray, this list probably would not grow...)
knownArrayTypes = ("NSMutableArray")

# Templates for accessor methods
# Substitutions will be performed on use:
#    &lt;key&gt; -&gt; normal key name
#    &lt;capKey&gt; -&gt; capitalized key name
#    &lt;ivar&gt; -&gt; instance variable name
#    &lt;type&gt; -&gt; key's type
#

objectAccessorDecls = """\
- (&lt;type&gt;)&lt;key&gt;;
- (void)set&lt;capKey&gt;:(&lt;type&gt;)value;

"""

objectAccessorDefs = """\
- (&lt;type&gt;)&lt;key&gt; {
    return [[&lt;ivar&gt; retain] autorelease];
}

- (void)set&lt;capKey&gt;:(&lt;type&gt;)value {
    if (&lt;ivar&gt; != value) {
        [&lt;ivar&gt; release];
        &lt;ivar&gt; = [value copy];
    }
}

"""

scalarAccessorDecls = """\
- (&lt;type&gt;)&lt;key&gt;;
- (void)set&lt;capKey&gt;:(&lt;type&gt;)value;

"""

scalarAccessorDefs = """\
- (&lt;type&gt;)&lt;key&gt; {
    return &lt;ivar&gt;;
}

- (void)set&lt;capKey&gt;:(&lt;type&gt;)value {
    if (&lt;ivar&gt; != value) {
        &lt;ivar&gt; = value;
    }
}

"""

indexedAccessorDecls = """\
- (NSArray *)&lt;key&gt;;
- (unsigned)countOf&lt;capKey&gt;;
- (id)objectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex;
- (void)get&lt;capKey&gt;:(id *)objsPtr range:(NSRange)range;
- (void)insertObject:(id)obj in&lt;capKey&gt;AtIndex:(unsigned)theIndex;
- (void)removeObjectFrom&lt;capKey&gt;AtIndex:(unsigned)theIndex;
- (void)replaceObjectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex withObject:(id)obj;

"""

indexedAccessorDefs = """\
- (NSArray *)&lt;key&gt; {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    return [[&lt;ivar&gt; retain] autorelease];
}

- (unsigned)countOf&lt;capKey&gt; {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    return [&lt;ivar&gt; count];
}

- (id)objectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    return [&lt;ivar&gt; objectAtIndex:theIndex];
}

- (void)get&lt;capKey&gt;:(id *)objsPtr range:(NSRange)range {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; getObjects:objsPtr range:range];
}

- (void)insertObject:(id)obj in&lt;capKey&gt;AtIndex:(unsigned)theIndex {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; insertObject:obj atIndex:theIndex];
}

- (void)removeObjectFrom&lt;capKey&gt;AtIndex:(unsigned)theIndex {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; removeObjectAtIndex:theIndex];
}

- (void)replaceObjectIn&lt;capKey&gt;AtIndex:(unsigned)theIndex withObject:(id)obj {
    if (!&lt;ivar&gt;) {
        &lt;ivar&gt; = [[NSMutableArray alloc] init];
    }
    [&lt;ivar&gt; replaceObjectAtIndex:theIndex withObject:obj];
}


"""

# ================== Runtime variables ==================

# ================== Script ==================

# Get input lines
if doDebug:
    inputLines = testInput
else:
    inputLines = sys.stdin.readlines()

# Strip comments and extra whitespace
commentRE1 = re.compile(r"[ 	]*\/\/.*$")
commentRE2 = re.compile(r"[ 	]*\/\*.*\*\/[ 	]*")

newInputLines = []
for curLine in inputLines:
    curLine = re.sub(commentRE1, "", curLine)
    curLine = re.sub(commentRE2, "", curLine)
    curLine = curLine.strip()
    if curLine != "":
        newInputLines.append(curLine)

inputLines = newInputLines

# Process each line

# Subexpressions:
#     1 - IBOutlet decl
#     2 - Type name (without pointer *'s)
#     3 - Pointer *'s from type
#     4 - Leading underbar(s) of variable name
#     5 - First letter of variable name
#     6 - Rest of variable name
declRE = re.compile(r"^(IBOutlet)?[ 	]*([_a-zA-Z][_a-zA-Z0-9]*)[ 	]*(\**)[ 	]*([_]*)([a-zA-Z])([_a-zA-Z0-9]*)[ 	]*;")

typeRE = re.compile(r"&lt;type&gt;", re.MULTILINE)
keyRE = re.compile(r"&lt;key&gt;", re.MULTILINE)
capKeyRE = re.compile(r"&lt;capKey&gt;", re.MULTILINE)
ivarRE = re.compile(r"&lt;ivar&gt;", re.MULTILINE)

resultText = ""

for curLine in inputLines:
    # Match the line and extract the subexpressions
    matchObj = re.match(declRE, curLine)
    if matchObj != None:
        # Note indices are 1 less than subexpression numbers in the comment above
        subexps = matchObj.groups()
        
        isObject = True
        isArray = False
        if subexps[1] in knownScalarTypes:
            isObject = False
        elif subexps[1] in knownArrayTypes:
            isArray = True
        
        # Figure out the substitution strings for the accessor templates
        if subexps[2] != "":
            curType = subexps[1] + " " + subexps[2]
        else:
            curType = subexps[1]
        curKey = subexps[4] + subexps[5]
        curCapKey = string.upper(subexps[4]) + subexps[5]
        curIvar = subexps[3] + subexps[4] + subexps[5]
        
        # Build the result
        if isObject:
            if isArray:
                curResultText = indexedAccessorDefs
            else:
                curResultText = objectAccessorDefs
        else:
            curResultText = scalarAccessorDefs

        curResultText = re.sub(typeRE, curType, curResultText)
        curResultText = re.sub(keyRE, curKey, curResultText)
        curResultText = re.sub(capKeyRE, curCapKey, curResultText)
        curResultText = re.sub(ivarRE, curIvar, curResultText)
        
        resultText += curResultText


# The comma suppresses adding another newline to the end
print resultText,
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>6</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>5A5FD548-E00A-4A01-95BA-E4A0653D152D</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string>@{</string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Place Method Decls on Clipboard</string>
				<key>script</key>
				<string>#!/usr/bin/env ruby -wKU
# -*- coding: utf-8 -*-

# This regexp shamelessly stolen from the TextMate Objective-C bundle.
proto_re = /
            ^\s*                # Start of the line and optional space
            [+-]\s*             # a plus or minus for method specifier
            \([^)]+\)           # the return type in brackets
            (?:(?:\n|[^{])*)    
            (?m:.*?)            
            \{                  
          /x
protos = []
ARGF.read.scan(proto_re) { |match|
  protos &lt;&lt; match.sub(/(;)?(?m:\s+)\{$/, ';')
}
puts protos.join("\n")
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>6</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>6D3A9658-6DE5-49CF-9E1A-D03CDB4E3ABF</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScriptSeparator</string>
				<key>uuid</key>
				<string>0A16A1E5-190B-4F0B-B331-29E4FCE67947</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>1</integer>
				<key>keyEquivalent</key>
				<string>@|</string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Property from Instance Variable</string>
				<key>script</key>
				<string>/Users/mkhl/src/dotfiles/mac/Application Support/Developer/Shared/Xcode/PropertyFromInstanceVariable.pl</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>2</integer>
				<key>scriptOutput</key>
				<integer>0</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>C539AFED-5438-41B2-944F-4D508C54D16E</string>
			</dict>
		</array>
		<key>uuid</key>
		<string>BFBF1DA4-050C-4418-963D-3B796890CB8F</string>
	</dict>
	<dict>
		<key>ClassName</key>
		<string>XCUserScriptGroup</string>
		<key>name</key>
		<string>Text</string>
		<key>subNodes</key>
		<array>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Sort Selection</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Alphabetically sorts the lines of the selection

echo -n "%%%{PBXSelection}%%%"
sort &lt;&amp;0
echo -n "%%%{PBXSelection}%%%"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>16F0853F-D545-49A2-83F0-55873F355202</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Remove Duplicate Lines</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Alphabetically sorts the lines of the selection

echo -n "%%%{PBXSelection}%%%"
uniq &lt;&amp;0
echo -n "%%%{PBXSelection}%%%"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>2F004890-19F9-473B-978A-E3FF856CD17F</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Remove Non-Printing Characters</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Removes any non-printing characters from the selection
#
# WARNING - this does not try to be smart about encodings. If you're not using ASCII, you may be!

echo -n "%%%{PBXSelection}%%%"
tr -cd "[:print:]\t\n\r" &lt;&amp;0
echo -n "%%%{PBXSelection}%%%"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>E4313F08-F228-4078-80E5-7C72213BD22E</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Convert Non-Breaking Spaces</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Converts occurrences of opt-space to space

echo -n "%%%{PBXSelection}%%%"
sed 's/ / /g' &lt;&amp;0
echo -n "%%%{PBXSelection}%%%"</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>033140A8-F305-4FAA-9A63-9143AEF9468C</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScriptSeparator</string>
				<key>uuid</key>
				<string>1CD7B754-013E-473B-8F59-6EA36733BC4C</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Evaluate Expression</string>
				<key>script</key>
				<string>#! /bin/sh
#
# Evaluate the given mathematical expression using 'bc'

echo -n "%%%{PBXSelection}%%%"
echo -n `( echo 'scale = 3;' ; cat ; echo ) | bc` &lt;&amp;0
echo -n "%%%{PBXSelection}%%%"
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>63F6DC00-90C7-4190-B628-86EF5708C805</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScriptSeparator</string>
				<key>uuid</key>
				<string>6826DA1D-70BF-4A78-BD98-0F18C0A9A43D</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Convert Spaces to Tabs</string>
				<key>script</key>
				<string>#! /bin/sh

# Convert spaces to tabs in the selected text

# use AppleScript to get the current view's tab width
TABWIDTH=`osascript &lt;&lt; ENDOFSCRIPT
tell application "Xcode"
	set tabWidth to 4
	set myFile to associated file name of front window
	set textDocuments to text documents
	repeat with i in textDocuments
		if path of i is myFile then
			set tabWidth to call method "tabWidth" of i
		end if
	end repeat
	tabWidth
end tell
ENDOFSCRIPT
`

echo -n "%%%{PBXSelection}%%%"
unexpand -t ${TABWIDTH} &lt;&amp;0
echo -n "%%%{PBXSelection}%%%"
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>792533F0-D98D-44DB-A07D-314BC8B88053</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Convert Tabs to Spaces</string>
				<key>script</key>
				<string>#! /bin/sh

# Convert tabs to spaces in the selected text

# use AppleScript to get the current view's tab width
TABWIDTH=`osascript &lt;&lt; ENDOFSCRIPT
tell application "Xcode"
	set tabWidth to 4
	set myFile to associated file name of front window
	set textDocuments to text documents
	repeat with i in textDocuments
		if path of i is myFile then
			set tabWidth to call method "tabWidth" of i
		end if
	end repeat
	tabWidth
end tell
ENDOFSCRIPT
`

echo -n "%%%{PBXSelection}%%%"
expand -t ${TABWIDTH} &lt;&amp;0
echo -n "%%%{PBXSelection}%%%"
</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>FDAE2754-E25B-40E4-973D-9EB272CF7DB2</string>
			</dict>
		</array>
		<key>uuid</key>
		<string>F32BDD54-D704-4BCD-9E59-F51D5203E345</string>
	</dict>
	<dict>
		<key>ClassName</key>
		<string>XCUserScriptGroup</string>
		<key>name</key>
		<string>HeaderDoc</string>
		<key>subNodes</key>
		<array>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @header template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc comment for a header
#
# Inserts a template HeaderDoc comment for the header.
use strict;

# get path to document
my $headerPath = &lt;&lt;'HEADERPATH';
%%%{PBXFilePath}%%%
HEADERPATH
chomp $headerPath;
my $rootFileName = &amp;rootFileNameFromPath($headerPath);

print "/*!\n    \@header $rootFileName\n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#abstract#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#description#&gt;\n";
print "*/\n";

sub rootFileNameFromPath {
    my $path = shift;
    
    my @pathParts = split (m'/', $path);
    my $filename = pop (@pathParts);
    my $rootFileName = "$filename";
    $rootFileName =~ s/\.h$//;
    return $rootFileName;
}

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>4</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>E06CA397-35FF-4D2A-81A9-A06F50900641</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScriptSeparator</string>
				<key>uuid</key>
				<string>978EA5C4-2440-4D23-9C03-6DDFDB9B009D</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @class template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for class
use strict;

my $selection = &lt;&lt;'SELECTION';
%%%{PBXSelectedText}%%%
SELECTION
chomp $selection;
my $unmodifiedSelection = $selection;
$selection =~ s/\n/ /sg;     # put on one line, if necessary
$selection =~ s/\s+$//;      # remove any trailing spaces
$selection =~ s/\s{2,}/ /g;  # regularize remaining spaces


my $type = "\@class";

my $typeString = "$type";
if (($type eq "\@class") || ($type eq "\@category")) {
    if (length($selection) &amp;&amp; ($selection =~ /^\@interface/)) {
        my $tempString;
        # get rid of '@interface'
        ($tempString = $selection) =~ s/\@interface//;
        # remove spaces
        $tempString =~ s/\s+//;
        # find out if there's a superclass
        my @classes = split(/:/, $tempString);
        my $className = $classes[0];
        $typeString = "$type       $className";

        my $superclassEtc = '';
        if (scalar(@classes) &gt; 1) {
            $superclassEtc = $classes[1];
            $typeString .= "\n    \@superclass $superclassEtc";
        }
    }
}

print "/*!\n";
print "    $typeString\n";
print "    \@abstract    %%%{PBXSelection}%%%&lt;#(brief description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion  &lt;#(comprehensive description)#&gt;\n";
print "*/\n";
print $unmodifiedSelection;
exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>2C2D957C-9B31-417B-AA18-2A256EC22BF9</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @category template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for class
use strict;

my $selection = &lt;&lt;'SELECTION';
%%%{PBXSelectedText}%%%
SELECTION
chomp $selection;
my $unmodifiedSelection = $selection;
$selection =~ s/\n/ /sg;     # put on one line, if necessary
$selection =~ s/\s+$//;      # remove any trailing spaces
$selection =~ s/\s{2,}/ /g;  # regularize remaining spaces


my $type = "\@category";

my $typeString = "$type";
if (($type eq "\@class") || ($type eq "\@category")) {
    if (length($selection) &amp;&amp; ($selection =~ /^\@interface/)) {
        my $tempString;
        # get rid of '@interface'
        ($tempString = $selection) =~ s/\@interface//;
        # remove spaces
        $tempString =~ s/\s+//;
        # find out if there's a superclass
        my @classes = split(/:/, $tempString);
        my $className = $classes[0];
        $typeString = "$type       $className";

        my $superclassEtc = '';
        if (scalar(@classes) &gt; 1) {
            $superclassEtc = $classes[1];
            $typeString .= "\n    \@superclass $superclassEtc";
        }
    }
}

print "/*!\n";
print "    $typeString\n";
print "    \@abstract    %%%{PBXSelection}%%%&lt;#(brief description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion  &lt;#(comprehensive description)#&gt;\n";
print "*/\n";
print $unmodifiedSelection;
exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>3F4DDAB8-AB92-4A97-8D1F-D8FFED223985</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @protocol template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for class
use strict;

my $selection = &lt;&lt;'SELECTION';
%%%{PBXSelectedText}%%%
SELECTION
chomp $selection;
my $unmodifiedSelection = $selection;
$selection =~ s/\n/ /sg;     # put on one line, if necessary
$selection =~ s/\s+$//;      # remove any trailing spaces
$selection =~ s/\s{2,}/ /g;  # regularize remaining spaces


my $type = "\@protocol";

my $typeString = "$type";
if (($type eq "\@class") || ($type eq "\@category")) {
    if (length($selection) &amp;&amp; ($selection =~ /^\@interface/)) {
        my $tempString;
        # get rid of '@interface'
        ($tempString = $selection) =~ s/\@interface//;
        # remove spaces
        $tempString =~ s/\s+//;
        # find out if there's a superclass
        my @classes = split(/:/, $tempString);
        my $className = $classes[0];
        $typeString = "$type       $className";

        my $superclassEtc = '';
        if (scalar(@classes) &gt; 1) {
            $superclassEtc = $classes[1];
            $typeString .= "\n    \@superclass $superclassEtc";
        }
    }
}

if (length($selection) &amp;&amp; ($selection =~ /^\@protocol/)) {
    my $protocolNameEtc;
    # get rid of '@protocol'
    ($protocolNameEtc = $selection) =~ s/\@protocol//;
    #remove leading spaces
    $protocolNameEtc =~ s/^\s+//;
    $typeString = "$type       $protocolNameEtc";
}

print "/*!\n";
print "    $typeString\n";
print "    \@abstract    %%%{PBXSelection}%%%&lt;#(brief description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion  &lt;#(comprehensive description)#&gt;\n";
print "*/\n";
print $unmodifiedSelection;
exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>B24B2E91-2CFD-4C19-8888-120C1E7AAD3B</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @method template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# 
# Inserts a template HeaderDoc comment for an
# Objective-C method.
# If the user selects a method declaration and
# chooses this command, the template includes
# the method name and the names of each parameter.
# If the user doesn't select a declaration before issuing
# this command, a default template is inserted.

use strict;

my $selection = &lt;&lt;'SELECTION';
%%%{PBXSelectedText}%%%
SELECTION
chomp $selection;
my $unmodifiedSelection = $selection; # used to retain linebreaks in output

$selection =~ s/\n/ /sg;     # put on one line, if necessary
$selection =~ s/\s+$//;      # remove any trailing spaces
$selection =~ s/\s{2,}/ /g;  # regularize remaining spaces

my $displayMethodName= '';
my $returnsAValue= 0;
my @params = ();

# is it a method declaration that we understand?
if (length($selection) &amp;&amp; ($selection =~ /^[+-]/) &amp;&amp; ($selection =~ /;$/)) {
    # determine if it returns a value
    $selection =~ m/[+-]\s+(\((.*?)\))?(.*);/;
	my $return = $2;
	my $fullMethodName = $3;
	if ((defined($return)) &amp;&amp; ($return ne 'void')) {$returnsAValue=1;};
	
	if (defined($fullMethodName)) {
	    # get rid of type info for args
	    $fullMethodName =~ s/\(.*?\)//g;
	    
		if ($fullMethodName =~ /:/) {
			# get keyword:arg pairs
			my @keyArgPairs = split(/\s+/, $fullMethodName);
			
			foreach my $pair (@keyArgPairs) {
				if ($pair =~ /:/) { # don't treat parameters with spaces as method names
				    my @parts = split(/:/, $pair);
				    while (@parts) {
					    $displayMethodName .= shift(@parts).":";
					    push (@params, shift @parts);
				    }
				} else {
				    if (length($pair)) { # but do add them to the parameter list
					push (@params, $pair);
				    }
				}
			}
		} else {
			$displayMethodName = $fullMethodName;
		}
	}
}

print "/*!\n";
print "    \@method     $displayMethodName\n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#(brief description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#(comprehensive description)#&gt;\n";

foreach my $param (@params) {
	print "    \@param      $param &lt;#(description)#&gt;\n" if (defined($param));
}

print "    \@result     &lt;#(description)#&gt;\n" if ($returnsAValue);
print "*/\n";
print $unmodifiedSelection;

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>1</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>A301DDBF-6E6A-49C4-95D4-117CD007EB72</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScriptSeparator</string>
				<key>uuid</key>
				<string>460956BB-CDE0-4AE0-8888-B22E3B6D12BA</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @function template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for functions, types, enums, etc.
# 
# insertTypeCmt.pl - inserts a template HeaderDoc comment for a class/protocol/category.
use strict;

print "/*!\n    \@function\n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#(description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#(description)#&gt;\n";
print "    \@param      &lt;#(name) (description)#&gt;\n";
print "    \@result     &lt;#(description)#&gt;\n";
print "*/\n";

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>4</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>CFAD240A-6B2C-46EE-A2EB-5534DE538A0C</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @typedef template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for functions, types, enums, etc.
# 
# insertTypeCmt.pl - inserts a template HeaderDoc comment for a class/protocol/category.
use strict;

print "/*!\n    \@typedef \n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#(description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#(description)#&gt;\n";
print "    \@field      &lt;#(name) (description)#&gt;\n";
print "*/\n";

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>4</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>A0B2B24E-D98B-4A8D-BB09-53A3BB7A1A11</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @struct template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for functions, types, enums, etc.
# 
# insertTypeCmt.pl - inserts a template HeaderDoc comment for a class/protocol/category.
use strict;

print "/*!\n    \@struct \n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#(description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#(description)#&gt;\n";
print "    \@field      &lt;#(name) (description)#&gt;\n";
print "*/\n";

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>4</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>D215F4BA-DF0A-4ECD-8A6F-A99861BFAFDD</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @enum template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for functions, types, enums, etc.
# 
# insertTypeCmt.pl - inserts a template HeaderDoc comment for a class/protocol/category.
use strict;

print "/*!\n    \@enum \n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#(description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#(description)#&gt;\n";
print "    \@constant   &lt;#(name) (description)#&gt;\n";
print "*/\n";

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>4</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>64F7FCC0-1A01-450C-B2A2-EAA1C959C305</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @const template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for functions, types, enums, etc.
# 
# insertTypeCmt.pl - inserts a template HeaderDoc comment for a class/protocol/category.
use strict;

print "/*!\n    \@const \n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#(description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#(description)#&gt;\n";
print "*/\n";

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>4</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>07C19F58-DD0B-464D-826D-F8E609D76D78</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>Insert @defined template</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# Insert HeaderDoc template for functions, types, enums, etc.
# 
# insertTypeCmt.pl - inserts a template HeaderDoc comment for a class/protocol/category.
use strict;

print "/*!\n    \@defined \n";
print "    \@abstract   %%%{PBXSelection}%%%&lt;#(description)#&gt;%%%{PBXSelection}%%%\n";
print "    \@discussion &lt;#(description)#&gt;\n";
print "*/\n";

exit 0;</string>
				<key>scriptError</key>
				<integer>1</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>4</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>0822B60B-A967-4057-9023-90F828CB43B5</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScriptSeparator</string>
				<key>uuid</key>
				<string>CED74B00-BAC7-4AA0-A0DA-E17B6405A8DD</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>shell.perl</string>
				<key>name</key>
				<string>View HeaderDoc for this Header</string>
				<key>script</key>
				<string>#! /usr/bin/perl -w
# 
# generateHD.pl - Generate and display headerdoc for the current file.

use strict;
use File::Path;

# get path to document
my $headerPath = &lt;&lt;'HEADERPATH';
%%%{PBXFilePath}%%%
HEADERPATH
chomp $headerPath;

if (length($headerPath)) {
    my $outputDir = "/tmp/pb-tmp/Documentation";
    if (! -d $outputDir) { mkpath($outputDir); };
    
    my $stdOut = `/usr/bin/headerdoc2html -o $outputDir \"$headerPath\"`;
    
    my $rootFileName = &amp;rootFileNameFromPath($headerPath);
    my $framesetFile = "$outputDir/$rootFileName/index.html";
    
    if (-e $framesetFile) {
        `open \"$framesetFile\"`;
    } else {
        warn "Couldn't find $framesetFile.\n";
    }
}


sub rootFileNameFromPath {
    my $path = shift;
    my @pathParts = split (m'/', $path);
    my $filename = pop (@pathParts);
    my $rootFileName = "$filename";
    $rootFileName =~ s/\.h$//;
    return $rootFileName;
}

exit 0;
</string>
				<key>scriptError</key>
				<integer>0</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>0</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>7CA7DF41-1B47-4142-B870-0090F88271E7</string>
			</dict>
		</array>
		<key>uuid</key>
		<string>78C8B197-B2F4-4963-A252-FBCBE125E732</string>
	</dict>
	<dict>
		<key>ClassName</key>
		<string>XCUserScriptGroup</string>
		<key>name</key>
		<string>Property Lists</string>
		<key>subNodes</key>
		<array>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Parse File as Property List</string>
				<key>script</key>
				<string>#!/usr/bin/perl -w
#
# Uses plutil to verify that the current file is a valid plist

use FileHandle;
use File::Temp ("mkdtemp");
use File::Copy ("copy");
use File::Basename ("basename");
use Cwd ("chdir");

my $filename = basename("%%%{PBXFilePath}%%%");
my $temporary_directory = mkdtemp("/tmp/plistparseXXXX");

open(OUTFILE, "&gt; $temporary_directory/$filename") or die "Unable to create temporary file: $!";
print OUTFILE while(&lt;STDIN&gt;);
close(OUTFILE);

chdir("$temporary_directory");

my $output = `plutil -lint "$filename"`;
unlink "$temporary_directory/$filename";
rmdir "$temporary_directory";
print "$output";</string>
				<key>scriptError</key>
				<integer>0</integer>
				<key>scriptInput</key>
				<integer>2</integer>
				<key>scriptOutput</key>
				<integer>3</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>1AFADB89-4F7A-4EC2-A7C1-8D6F53EF01CF</string>
			</dict>
			<dict>
				<key>ClassName</key>
				<string>XCUserScript</string>
				<key>isFileScript</key>
				<integer>0</integer>
				<key>keyEquivalent</key>
				<string></string>
				<key>language</key>
				<string>xcode.lang.sh</string>
				<key>name</key>
				<string>Parse Selection as Property List</string>
				<key>script</key>
				<string>#!/usr/bin/perl -w
#
# Uses plutil to verify that the current file is a valid plist

use FileHandle;
use File::Temp ("mkdtemp");
use File::Copy ("copy");
use File::Basename ("basename");
use Cwd ("chdir");

my $filename = basename("%%%{PBXFilePath}%%%");
my $temporary_directory = mkdtemp("/tmp/plistparseXXXX");

open(OUTFILE, "&gt; $temporary_directory/$filename") or die "Unable to create temporary file: $!";
print OUTFILE while(&lt;STDIN&gt;);
close(OUTFILE);

chdir("$temporary_directory");

my $output = `plutil -lint "$filename"`;
unlink "$temporary_directory/$filename";
rmdir "$temporary_directory";
print "$output";</string>
				<key>scriptError</key>
				<integer>0</integer>
				<key>scriptInput</key>
				<integer>1</integer>
				<key>scriptOutput</key>
				<integer>3</integer>
				<key>scriptWorkingDirectory</key>
				<integer>3</integer>
				<key>uuid</key>
				<string>E4EED4E0-6A21-4BF7-8A67-4FA36E48581D</string>
			</dict>
		</array>
		<key>uuid</key>
		<string>114FF8DD-E900-42F9-B2E2-C79A8EF9931D</string>
	</dict>
</array>
</plist>
